# Section 10 — ElementGenerator & StyleGenerator

## Overview

ElementGenerator parses UXML files and generates an `El` class with `const string` names for every named element, typed private fields for element references, and an `InitElements(VisualElement root)` partial method that queries the visual tree and assigns each field. StyleGenerator parses USS files and generates a `Cls` class with `const string` class names and a `JUIVar` class with typed accessors for CSS custom properties. Together they eliminate magic strings and provide compile-time safety for all UXML/USS references.

## Dependencies

- Section 9 — Source Generator Project Setup (UxmlParser, UssParser, NamingConventions, DiagnosticDescriptors)

## File Structure

- `SourceGenerators/JEngine.JUI.Generators/ElementGenerator.cs`
- `SourceGenerators/JEngine.JUI.Generators/StyleGenerator.cs`
- `Runtime/JUI/Attributes/UIComponentAttribute.cs`

## API Design

### UIComponentAttribute

```csharp
namespace JEngine.JUI;

/// <summary>
/// Marks a partial class as a JUI component backed by a UXML template and optional USS stylesheet.
/// Triggers source generation of El, Cls, JUIVar, typed fields, and initialization methods.
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public sealed class UIComponentAttribute : Attribute
{
    /// <summary>
    /// Path to the UXML template file, relative to the project Assets or Packages folder.
    /// Must be registered as an additional file for the source generator to find it.
    /// </summary>
    public string UxmlPath { get; }

    /// <summary>
    /// Optional path to the USS stylesheet file. If null, only ElementGenerator runs
    /// (no Cls or JUIVar class is generated).
    /// </summary>
    public string UssPath { get; }

    /// <summary>
    /// Creates a UIComponent attribute linking a class to its UXML template and optional stylesheet.
    /// </summary>
    /// <param name="uxmlPath">Path to the UXML file. Must not be null or empty.</param>
    /// <param name="ussPath">Optional path to the USS file. Pass null to skip style generation.</param>
    public UIComponentAttribute(string uxmlPath, string ussPath = null)
    {
        UxmlPath = uxmlPath;
        UssPath = ussPath;
    }
}
```

### Generated El Class (ElementGenerator output)

```csharp
// Generated file: PlayerHUD.El.g.cs
// <auto-generated />

namespace HotUpdate.Code;

partial class PlayerHUD
{
    /// <summary>
    /// Compile-time constants for all named elements in PlayerHUD.uxml.
    /// Use these instead of magic strings when querying the visual tree.
    /// </summary>
    public static class El
    {
        public const string HealthText = "health-text";
        public const string HealthFill = "health-fill";
        public const string ManaBar = "mana-bar";
        public const string PlayerAvatar = "player-avatar";
    }

    // Typed fields for direct element access (assigned in InitElements)
    private Label _el_healthText;
    private VisualElement _el_healthFill;
    private VisualElement _el_manaBar;
    private VisualElement _el_playerAvatar;

    /// <summary>
    /// Queries the visual tree for all named elements and assigns typed fields.
    /// Called automatically by the component lifecycle after the root element is created.
    /// </summary>
    partial void InitElements(VisualElement root)
    {
        _el_healthText = root.Q<Label>(El.HealthText);
        _el_healthFill = root.Q<VisualElement>(El.HealthFill);
        _el_manaBar = root.Q<VisualElement>(El.ManaBar);
        _el_playerAvatar = root.Q<VisualElement>(El.PlayerAvatar);

#if DEBUG
        if (_el_healthText == null)
            UnityEngine.Debug.LogError($"[JUI] PlayerHUD: element '{El.HealthText}' not found in UXML");
        if (_el_healthFill == null)
            UnityEngine.Debug.LogError($"[JUI] PlayerHUD: element '{El.HealthFill}' not found in UXML");
        if (_el_manaBar == null)
            UnityEngine.Debug.LogError($"[JUI] PlayerHUD: element '{El.ManaBar}' not found in UXML");
        if (_el_playerAvatar == null)
            UnityEngine.Debug.LogError($"[JUI] PlayerHUD: element '{El.PlayerAvatar}' not found in UXML");
#endif
    }
}
```

### Generated Cls and JUIVar Classes (StyleGenerator output)

```csharp
// Generated file: PlayerHUD.Cls.g.cs
// <auto-generated />

namespace HotUpdate.Code;

partial class PlayerHUD
{
    /// <summary>
    /// Compile-time constants for all CSS class names in PlayerHUD.uss.
    /// Use these with AddToClassList / RemoveFromClassList instead of magic strings.
    /// </summary>
    public static class Cls
    {
        public const string BarFill = "bar-fill";
        public const string BarFillCritical = "bar-fill--critical";
        public const string BarFillLow = "bar-fill--low";
        public const string PlayerName = "player-name";
        public const string PlayerNameActive = "player-name--active";
        public const string HudContainer = "hud-container";
    }

    /// <summary>
    /// Typed accessors for CSS custom properties (variables) defined in PlayerHUD.uss.
    /// Provides compile-time safe access to USS variables with correct value types.
    /// </summary>
    public static class JUIVar
    {
        /// <summary>--bar-color (Color)</summary>
        public static readonly CustomStyleProperty<Color> BarColor =
            new CustomStyleProperty<Color>("--bar-color");

        /// <summary>--bar-height (Length)</summary>
        public static readonly CustomStyleProperty<StyleLength> BarHeight =
            new CustomStyleProperty<StyleLength>("--bar-height");

        /// <summary>--hud-opacity (Float)</summary>
        public static readonly CustomStyleProperty<float> HudOpacity =
            new CustomStyleProperty<float>("--hud-opacity");

        /// <summary>--player-title (String)</summary>
        public static readonly CustomStyleProperty<string> PlayerTitle =
            new CustomStyleProperty<string>("--player-title");
    }
}
```

## Data Structures

- `El` -- static nested class containing `const string` fields. One field per named UXML element. Field name is the PascalCase conversion of the kebab-case element name. Field value is the original kebab-case name.
- `_el_*` -- private instance fields of the UI Toolkit element type. One per named UXML element. Field name is `_el_` + camelCase conversion of the kebab-case element name.
- `Cls` -- static nested class containing `const string` fields. One field per unique CSS class selector in the USS file. Field name is BEM-to-PascalCase. Field value is the raw CSS class name (without the leading dot).
- `JUIVar` -- static nested class containing `static readonly CustomStyleProperty<T>` fields. One field per CSS custom property. The generic type parameter is inferred from the USS value.

## Implementation Notes

- **ElementGenerator pipeline**:
  1. `SyntaxProvider` filters for classes with `[UIComponent]` attribute via `ForAttributeWithMetadataName`.
  2. `AdditionalTextsProvider` filtered to `.uxml` files.
  3. `Combine` matches the class's `UxmlPath` to the correct additional file.
  4. `UxmlParser.Parse()` extracts named elements.
  5. `NamingConventions.KebabToPascal()` and `KebabToCamel()` convert names.
  6. Generator emits the `El` class, typed fields, and `InitElements` method.

- **StyleGenerator pipeline**:
  1. Same `SyntaxProvider` as ElementGenerator (reuses the `[UIComponent]` class filter).
  2. `AdditionalTextsProvider` filtered to `.uss` files.
  3. `Combine` matches the class's `UssPath` to the correct additional file. If `UssPath` is null, no output is emitted.
  4. `UssParser.ParseClasses()` and `UssParser.ParseVariables()` extract data.
  5. `NamingConventions.BemToPascal()` and `CssVarToPascal()` convert names.
  6. Generator emits the `Cls` class and `JUIVar` class.

- **Element type resolution**: The UXML parser maintains a type map for built-in UI Toolkit elements:
  | UXML Tag | C# Type |
  |---|---|
  | `ui:VisualElement` | `VisualElement` |
  | `ui:Label` | `Label` |
  | `ui:Button` | `Button` |
  | `ui:TextField` | `TextField` |
  | `ui:Toggle` | `Toggle` |
  | `ui:Slider` | `Slider` |
  | `ui:SliderInt` | `SliderInt` |
  | `ui:ScrollView` | `ScrollView` |
  | `ui:Foldout` | `Foldout` |
  | `ui:ListView` | `ListView` |
  | `ui:DropdownField` | `DropdownField` |
  | (custom namespace) | Fully qualified type name |

  Unknown tags default to `VisualElement` with a `JUI005` warning.

- **Debug null checks**: The `#if DEBUG` block in `InitElements` logs errors for any element that could not be found in the visual tree at runtime. This catches UXML/code mismatches during development without impacting release builds.

- **Partial method pattern**: `InitElements` is declared as a `partial void` method on the base component. The generator provides the implementation. If no UXML elements are named, the partial method is left unimplemented (compiler removes the call site).

- **Namespace handling**: The generated partial class is emitted in the same namespace as the user's class. The generator reads the namespace from the semantic model.

- **Multiple classes in one file**: The generator handles multiple `[UIComponent]` classes in the same source file correctly, emitting separate generated files for each.

## Source Generator Notes

### ElementGenerator

```csharp
[Generator]
public sealed class ElementGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Find classes with [UIComponent]
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "JEngine.JUI.UIComponentAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, ct) => ExtractClassInfo(ctx, ct));

        // Step 2: Find UXML additional files
        var uxmlFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(".uxml"));

        // Step 3: Combine and generate
        var combined = classDeclarations.Combine(uxmlFiles.Collect());

        context.RegisterSourceOutput(combined,
            static (spc, pair) => Execute(spc, pair.Left, pair.Right));
    }
}
```

### StyleGenerator

```csharp
[Generator]
public sealed class StyleGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Find classes with [UIComponent] that have a UssPath
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "JEngine.JUI.UIComponentAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, ct) => ExtractClassInfo(ctx, ct))
            .Where(static info => info.UssPath != null);

        // Step 2: Find USS additional files
        var ussFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(".uss"));

        // Step 3: Combine and generate
        var combined = classDeclarations.Combine(ussFiles.Collect());

        context.RegisterSourceOutput(combined,
            static (spc, pair) => Execute(spc, pair.Left, pair.Right));
    }
}
```

## Usage Examples

```xml
<!-- PlayerHUD.uxml -->
<ui:UXML xmlns:ui="UnityEngine.UIElements">
    <ui:VisualElement name="hud-root" class="hud-container">
        <ui:Label name="health-text" class="player-name" text="100" />
        <ui:VisualElement name="health-fill" class="bar-fill" />
        <ui:VisualElement name="mana-bar" class="bar-fill" />
        <ui:VisualElement name="player-avatar" />
        <!-- This element has no name, so it is NOT included in El -->
        <ui:VisualElement class="spacer" />
    </ui:VisualElement>
</ui:UXML>
```

```css
/* PlayerHUD.uss */
.hud-container {
    flex-direction: column;
    --hud-opacity: 1.0;
}

.bar-fill {
    height: 20px;
    --bar-color: #00ff00;
    --bar-height: 20px;
}

.bar-fill--critical {
    --bar-color: #ff0000;
}

.bar-fill--low {
    --bar-color: #ffaa00;
}

.player-name {
    font-size: 16px;
    --player-title: "Hero";
}

.player-name--active {
    color: white;
}
```

```csharp
// Developer writes:
[UIComponent("PlayerHUD.uxml", "PlayerHUD.uss")]
public partial class PlayerHUD : JUIComponent
{
    private readonly Signal<int> _health = new(100);
    private readonly Signal<int> _maxHealth = new(100);

    protected override void OnMount()
    {
        // Fields are already assigned by InitElements (called in lifecycle)
        // Use El constants for any additional queries:
        var extra = Root.Q<VisualElement>(El.HealthFill);

        // Use Cls constants for dynamic class toggling:
        _el_healthFill.AddToClassList(Cls.BarFill);

        // Use JUIVar for reading custom style properties:
        _el_healthFill.RegisterCallback<CustomStyleResolvedEvent>(evt =>
        {
            if (evt.customStyle.TryGetValue(JUIVar.BarColor, out var color))
            {
                // Use color value
            }
        });
    }
}
```

```csharp
// Accessing generated constants from outside the component:
public class HudTestHelper
{
    public void VerifyElements(VisualElement root)
    {
        // El and Cls are public nested classes, accessible externally
        var label = root.Q<Label>(PlayerHUD.El.HealthText);
        Assert.IsNotNull(label);

        Assert.IsTrue(label.ClassListContains(PlayerHUD.Cls.PlayerName));
    }
}
```

## Test Plan

1. **El class contains all named elements**: Parse UXML with 3 named and 2 unnamed elements, verify El has exactly 3 const string fields.
2. **El const values match original names**: Verify `El.HealthText == "health-text"` (original kebab-case preserved as the value).
3. **Kebab-to-PascalCase mapping correct**: Verify `health-text` -> `HealthText`, `mana-bar` -> `ManaBar`, `player-avatar` -> `PlayerAvatar`.
4. **Typed fields match UXML element types**: Verify `<ui:Label name="x">` generates `private Label _el_x`, `<ui:Button name="y">` generates `private Button _el_y`.
5. **Unknown element type defaults to VisualElement**: Parse a custom element `<custom:Foo name="bar">` with no type mapping, verify field is `VisualElement` and JUI005 warning emitted.
6. **Debug null checks emitted**: Verify `#if DEBUG` block contains `Debug.LogError` for each element.
7. **No debug checks in release**: Verify the `#if DEBUG` block is properly conditional (not emitted unconditionally).
8. **Cls class contains all CSS classes**: Parse USS with 4 class selectors, verify Cls has 4 const string fields.
9. **BEM-to-PascalCase mapping**: Verify `bar-fill--critical` -> `BarFillCritical`, `player-name--active` -> `PlayerNameActive`.
10. **JUIVar infers Color type**: Verify `--bar-color: #00ff00` produces `CustomStyleProperty<Color>`.
11. **JUIVar infers Length type**: Verify `--bar-height: 20px` produces `CustomStyleProperty<StyleLength>`.
12. **JUIVar infers Float type**: Verify `--hud-opacity: 1.0` produces `CustomStyleProperty<float>`.
13. **JUIVar infers String type**: Verify `--player-title: "Hero"` produces `CustomStyleProperty<string>`.
14. **No Cls/JUIVar when UssPath is null**: Set `[UIComponent("test.uxml")]` without USS path, verify no Cls or JUIVar class is generated.
15. **Duplicate element names emit JUI002**: UXML with two elements named `health-text`, verify JUI002 warning.
16. **Empty element name emits JUI001**: UXML with `name=""`, verify JUI001 warning.
17. **UXML not found emits JUI003**: Reference a non-existent UXML path, verify JUI003 error.
18. **Class not partial emits JUI101**: Apply `[UIComponent]` to a non-partial class, verify JUI101 error and no code generated.

## Acceptance Criteria

- [ ] `UIComponentAttribute` accepts `uxmlPath` (required) and `ussPath` (optional) parameters
- [ ] ElementGenerator emits `El` nested class with `const string` for each named UXML element
- [ ] ElementGenerator emits typed private fields (`_el_*`) matching UXML element types
- [ ] ElementGenerator emits `InitElements(VisualElement root)` with `Q<T>()` calls
- [ ] Debug builds include null-check logging for each element query
- [ ] StyleGenerator emits `Cls` nested class with `const string` for each USS class selector
- [ ] StyleGenerator emits `JUIVar` nested class with typed `CustomStyleProperty<T>` for each CSS variable
- [ ] CSS variable types are correctly inferred: Color, Length, Float, String
- [ ] Kebab-case to PascalCase conversion is correct for element names
- [ ] BEM to PascalCase conversion is correct for class names (block, element, modifier segments)
- [ ] No generation occurs when UXML/USS files are missing (diagnostic emitted instead)
- [ ] Non-partial classes emit JUI101 error
- [ ] Generated code compiles without warnings in Unity 2022.3+
- [ ] All generated code includes `// <auto-generated />` header
- [ ] El and Cls classes are `public static` for external access
